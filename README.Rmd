---
output: github_document
bibliography: vignettes/bibliography.bib
link-citations: TRUE
nocite: |
  @HillierEtAl2009
  @Smith1989
  @Smith1993
csl: vignettes/minimal_style.csl
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
```{r setup, include = FALSE}
require(qfratio)
set.seed(64501)
```

# qfratio: R Package for Moments of Ratios of Quadratic Forms

<!-- badges: start -->
[![R-CMD-check](https://github.com/watanabe-j/qfratio/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/watanabe-j/qfratio/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->


This package provides functions to evaluate moments of ratios
(and products) of quadratic forms in normal variables, specifically using
recursive algorithms developed by @BaoKan2013 and @HillierEtAl2014.
Generating functions for these moments are closely related to the
top-order zonal and invariant polynomials of matrix arguments.

There exist a couple of `Matlab` programs developed by Raymond Kan
(available from <https://www-2.rotman.utoronto.ca/~kan/>), but this
`R` package is an independent project (not a fork or translation)
and has different functionalities, including evaluation of moments of
multiple ratios of a particular form and scaling to avoid numerical overflow.
This has originally been developed for a biological application,
specifically for evaluating average evolvability measures in
evolutionary quantitative genetics [@Watanabe2022cevo].



## Installation

***WARNING*** Installation size of this package can be very large
(~130 MB on Linux and macOS; ~3 MB on Windows with `Rtools42`),
as it involves lots of `RcppEigen` functions.


### From CRAN (stable version)
```{r eval = FALSE}
install.packages("qfratio")
```


### From GitHub (development version)
```{r eval = FALSE}
## Install devtools first:
# install.packages("devtools")

## Recommended installation (pandoc required):
devtools::install_github("watanabe-j/qfratio", dependencies = TRUE, build_vignettes = TRUE)

## Minimal installation:
# devtools::install_github("watanabe-j/qfratio")
```

### Dependencies

    Imports: Rcpp, MASS
    LinkingTo: Rcpp, RcppEigen
    Suggests: gsl, mvtnorm, graphics, stats, testthat (>= 3.0.0), rlang (>= 0.4.7),
              knitr, rmarkdown

If installing from GitHub, you also need [`pandoc`](https://pandoc.org) for
correctly building the vignette.
For `pandoc < 2.11`, `pandoc-citeproc` is required as well.
(Never mind if you use `RStudio`, which appears to have them bundled.)


## Examples

Here are some simple examples:

```{r, examples}
## Simple matrices
nv <- 4
A <- diag(1:nv)
B <- diag(sqrt(nv:1))

## Expectation of (x^T A x)^2 / (x^T x)^2 where x ~ N(0, I)
qfrm(A, p = 2)

## Compare with Monte Carlo mean
mean(rqfr(1000, A = A, p = 2))

## Expectation of (x^T A x)^1/2 / (x^T x)^1/2
(mom_A0.5 <- qfrm(A, p = 1/2))

## Monte Carlo mean
mean(rqfr(1000, A = A, p = 1/2))

plot(mom_A0.5)

## Expectation of (x^T x) / (x^T A^-1 x)
##   = "average conditional evolvability"
(avr_cevoA <- qfrm(diag(nv), solve(A)))

mean(rqfr(1000, A = diag(nv), B = solve(A), p = 1))
plot(avr_cevoA)

## Expectation of (x^T x)^2 / (x^T A x) (x^T A^-1 x)
##   = "average autonomy"
(avr_autoA <- qfmrm(diag(nv), A, solve(A), p = 2, q = 1, r = 1))

mean(rqfmr(1000, A = diag(nv), B = A, D = solve(A), p = 2, q = 1, r = 1))
plot(avr_autoA)

## Expectation of (x^T A B x) / ((x^T A^2 x) (x^T B^2 x))^1/2
##   = "average response correlation"
## whose Monte Carlo evaluation is called the "random skewers" analysis,
## while this is essentially an analytic solution (with slight truncation error)
(avr_rcorA <- qfmrm(crossprod(A, B), crossprod(A), crossprod(B),
                    p = 1, q = 1/2, r = 1/2))

mean(rqfmr(1000, A = crossprod(A, B), B = crossprod(A), D = crossprod(B),
           p = 1, q = 1/2, r = 1/2))
plot(avr_rcorA)


## More complex (but arbitrary) example
## Expectation of (x^T A x)^2 / (x^T B x)^3 where x ~ N(mu, Sigma)
mu <- 1:nv / nv
Sigma <- diag(runif(nv) * 3)
(mom_A2B3 <- qfrm(A, B, p = 2, q = 3, mu = mu, Sigma = Sigma,
                  m = 500, use_cpp = TRUE))
plot(mom_A2B3)
```


## References
