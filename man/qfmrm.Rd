% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ratio_fun.R
\name{qfmrm}
\alias{qfmrm}
\alias{qfmrm_ApBIqr_int}
\alias{qfmrm_ApBIqr_npi}
\alias{qfmrm_IpBDqr_gen}
\alias{qfmrm_ApBDqr_int}
\alias{qfmrm_ApBDqr_npi}
\title{Moment of multiple ratio of quadratic forms in normal variables}
\usage{
qfmrm(
  A,
  B,
  D,
  p = 1,
  q = p/2,
  r = q,
  m = 100L,
  mu = rep.int(0, n),
  Sigma = diag(n),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = .Machine$double.eps * 100,
  ...
)

qfmrm_ApBIqr_int(
  A,
  B,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  mu = rep.int(0, n),
  error_bound = TRUE,
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaB = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = .Machine$double.eps * 100,
  thr_margin = 100
)

qfmrm_ApBIqr_npi(
  A,
  B,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  mu = rep.int(0, n),
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaA = 1,
  alphaB = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = .Machine$double.eps * 100,
  thr_margin = 100
)

qfmrm_IpBDqr_gen(
  B,
  D,
  p = 1,
  q = 1,
  r = 1,
  mu = rep.int(0, n),
  m = 100L,
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaB = 1,
  alphaD = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = .Machine$double.eps * 100,
  thr_margin = 100
)

qfmrm_ApBDqr_int(
  A,
  B,
  D,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  mu = rep.int(0, n),
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaB = 1,
  alphaD = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = .Machine$double.eps * 100,
  thr_margin = 100
)

qfmrm_ApBDqr_npi(
  A,
  B,
  D,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  mu = rep.int(0, n),
  check_convergence = c("relative", "strict_relative", "absolute", "none"),
  use_cpp = TRUE,
  cpp_method = c("double", "long_double", "coef_wise"),
  nthreads = 0,
  alphaA = 1,
  alphaB = 1,
  alphaD = 1,
  tol_conv = .Machine$double.eps^(1/4),
  tol_zero = .Machine$double.eps * 100,
  tol_sing = .Machine$double.eps * 100,
  thr_margin = 100
)
}
\arguments{
\item{A, B, D}{Argument matrices. Should be square. Automatically symmetrized.}

\item{p, q, r}{Exponents for \eqn{\mathbf{A}}, \eqn{\mathbf{B}}, and \eqn{\mathbf{D}},
respectively. By default, \code{q} equals \code{p/2} and
\code{r} equals \code{q}. If unsure, specify all explicitly.}

\item{m}{Order of polynomials at which the series expression is truncated.
\eqn{M} in Hillier et al. (2009, 2014).}

\item{mu}{Mean vector \eqn{\bm{\mu}} for \eqn{\mathbf{x}}}

\item{Sigma}{Covariance matrix \eqn{\mathbf{\Sigma}} for \eqn{\mathbf{x}}.
Accommodated only by the front-end \code{qfmrm()}. See "Details"
in \code{\link{qfrm}}.}

\item{tol_zero}{Tolerance against which numerical zero is determined.  Used to determine,
e.g., whether \code{mu} is a zero vector, \code{A} or \code{B} equals
the identity matrix, etc.}

\item{tol_sing}{Tolerance against which matrix singularity and rank are determined.
The eigenvalues smaller than this are considered zero.}

\item{...}{Additional arguments in the front-end \code{qfmrm()} will be passed to
the appropriate ``internal'' function.}

\item{error_bound}{Logical to specify whether the error bound is returned (if available).}

\item{check_convergence}{Specifies how convergence check is done (see "Details"). Options:
\itemize{
\item{\code{"relative"}: }{default; magnitude of the last term of
the series relative to the sum is compared with \code{tol_conv}}
\item{\code{"strict_relative"} or \code{TRUE}: }{same, but stricter than
default by setting \code{tol_conv = .Machine$double.eps}}
\item{\code{"absolute"}: }{absolute magnitude of the last term is
compared with \code{tol_conv}}
\item{\code{"none"} or \code{FALSE}: }{skips convergence check}
}}

\item{use_cpp}{Logical to specify whether the calculation is done with \code{C++}
functions via \code{Rcpp}. \code{TRUE} by default.}

\item{cpp_method}{Method used in \code{C++} calculations to avoid numerical
overflow/underflow (see "Details"). Options:
\itemize{
\item{\code{"double"}: }{default; fastest but prone to underflow in
some conditions}
\item{\code{"long_double"}: }{same algorithm but using the
\code{long double} variable type; robust but slow and
memory-inefficient}
\item{\code{"coef_wise"}: }{coefficient-wise scaling algorithm;
robust but variably slow}
}}

\item{nthreads}{Number of threads used in OpenMP-enabled \code{C++} functions.
See "Details".}

\item{tol_conv}{Tolerance against which numerical convergence of series is checked.
Used with \code{check_convergence}.}

\item{thr_margin}{Optional argument to adjust the threshold for scaling (see "Scaling"
in \code{\link{d1_i}}). Passed to internal functions (\code{\link{d1_i}},
\code{\link{d2_ij}}, \code{\link{d3_ijk}}) or their \code{C++} equivalents.}

\item{alphaA, alphaB, alphaD}{Factors for the scaling constants for \eqn{\mathbf{A}},
\eqn{\mathbf{B}}, and \eqn{\mathbf{D}}, respectively. See "Details" in
\code{\link{qfrm}}.}
}
\description{
\code{qfmrm()} is a front-end function to obtain the (compound) moment
of a multiple ratio of quadratic forms in normal variables in the following
special form:
\eqn{ \mathrm{E} \left(
  \frac{(\mathbf{x^\mathit{T} A x})^p }{(\mathbf{x^\mathit{T} B x})^q (\mathbf{x^\mathit{T} D x})^r}
  \right) },
where \eqn{\mathbf{x} \sim N(\bm{\mu}, \mathbf{\Sigma})}.
Like \code{qfrm()}, this function calls one of the following ``internal''
functions for actual calculation, as appropriate.

\code{qfmrm_ApBIqr_int()}: For \eqn{\mathbf{D} = \mathbf{I}_n} and
positive-integral \eqn{p}

\code{qfmrm_ApBIqr_npi()}: For \eqn{\mathbf{D} = \mathbf{I}_n} and
non-integral \eqn{p}

\code{qfmrm_IpBDqr_gen()}: For \eqn{\mathbf{A} = \mathbf{I}_n}

\code{qfmrm_ApBDqr_int()}: For general \eqn{\mathbf{A}}, \eqn{\mathbf{B}},
and \eqn{\mathbf{D}}, and positive-integral \eqn{p}

\code{qfmrm_ApBDqr_npi()}: For general \eqn{\mathbf{A}}, \eqn{\mathbf{B}},
and \eqn{\mathbf{D}}, and non-integral \eqn{p}
}
\details{
The usage of these functions is similar to \code{\link{qfrm}}, to which
the user is referred for documentation.
It is of course assumed that \eqn{\mathbf{B} \neq \mathbf{D}}
(otherwise, the problem reduces to a simple ratio).

When \code{B} is identity or missing, this and its exponent \code{q} will
be swapped with \code{D} and \code{r}, respectively, before
\code{qfmrm_ApBIqr_***()} is called.

The error bound is only available for \code{qfmrm_ApBIqr_int()}.
This is similar to, though slightly different from, that
in \code{qfrm_ApBq_int()}.

The existence conditions for the moments of this multiple ratio can be
reduced to those for a simple ratio, provided that one of the null spaces
of \eqn{\mathbf{B}} and \eqn{\mathbf{D}} is a subspace of the other
(including the case they are null).
The conditions of Bao & Kan (2013: proposition 1) can then be
applied by replacing \eqn{q} and \eqn{m} there by \eqn{q + r} and
\eqn{\min{( \mathrm{rank}(\mathbf{B}), \mathrm{rank}(\mathbf{D}) )}},
respectively (see also Smith 1989: p. 258 for
nonsingular \eqn{\mathbf{B}}, \eqn{\mathbf{D}}).
An error is thrown if these conditions are not met in this case.
Otherwise (i.e., \eqn{\mathbf{B}} and \eqn{\mathbf{D}} are both singular
and neither of their null spaces is a subspace of the other), it seems
difficult to define general moment existence conditions.  A sufficient
condition can be obtained by applying the same proposition with a new
denominator matrix whose null space is union of those of \eqn{\mathbf{B}}
and \eqn{\mathbf{D}} (Watanabe, 2022).  A warning is thrown if that
condition is not met in this case.

Note that these functions may take a substantially longer computational time
than those pertaining to a simple ratio, because multiple matrices means
multiple infinite series along which summation is to be taken.
Expect the computational time to scale with \code{m^2} for
\code{qfmrm_IpBDqr_gen()} (when \code{mu} is zero),
\code{qfmrm_ApBIqr_int()}, and \code{qfmrm_ApBDqr_int()}, and \code{m^3} for
the rest.

All these functions can use \code{C++} versions to speed up computation;
set \code{use_cpp = TRUE}.
Furthermore, some of the \code{C++} functions, in particular those
using three matrix arguments, are parallelized with \code{OpenMP}
(when available). Use the argument \code{nthreads} to control the number
of \code{OpenMP} threads. By default (\code{nthreads = 0}), they use
one-half of the processors detected via \code{omp_get_num_procs()}.
These will not take effect when all the argument matrices share
the same eigenvectors (so that the calculation only involves element-wise
operations of eigenvalues), because the \code{OpenMP} parallelization
does not seem to improve performance in that case
(and this is typically fast anyway).

Most of these functions, excepting \code{qfmrm_ApBiqr_int()} with zero
\code{mu}, involve evaluation of multiple series, which can suffer
from numerical overflow and underflow (see "Scaling" in
\code{\link{d1_i}} and "Details" in \code{\link{qfrm}}). To avoid this,
\code{cpp_method = "long_double"} or \code{"coef_wise"} options can be used
(see "Details" in \code{\link{qfrm}}).
}
\examples{
## Some symmetric matrices and parameters
nv <- 4
A <- diag(nv:1)
B <- diag(sqrt(1:nv))
D <- diag((1:nv)^2 / nv)
mu <- nv:1 / nv
Sigma <- matrix(0.5, nv, nv)
diag(Sigma) <- 1

## Expectation of (x^T A x)^2 / (x^T B x) (x^T x) where x ~ N(0, I)
(res1 <- qfmrm(A, B, p = 2, q = 1, r = 1))
plot(res1)

# The above internally calls the following:
qfmrm_ApBIqr_int(A, B, p = 2, q = 1, r = 1) ## The same

# Similar result with different expression
# This is a suboptimal option and throws a warning
qfmrm_ApBIqr_npi(A, B, p = 2, q = 1, r = 1)

## Expectation of (x^T A x) / (x^T B x)^(1/2) (x^T D x)^(1/2) where x ~ N(0, I)
(res2 <- qfmrm(A, B, D, p = 1, q = 1/2, r = 1/2))
plot(res2)

# The above internally calls the following:
qfmrm_ApBDqr_int(A, B, D, p = 1, q = 1/2, r = 1/2) ## The same

## Average response correlation between A and B
(res3 <- qfmrm(crossprod(A, B), crossprod(A), crossprod(B),
               p = 1, q = 1/2, r = 1/2))
plot(res3)

## Same, but with x ~ N(mu, Sigma)
(res4 <- qfmrm(crossprod(A, B), crossprod(A), crossprod(B),
               p = 1, q = 1/2, r = 1/2, mu = mu, Sigma = Sigma))
plot(res4)

## Average autonomy of D
(res5 <- qfmrm(B = D, D = solve(D), p = 2, q = 1, r = 1))
plot(res5)

}
\references{
Bao, Y. & Kan, R. (2013). On the moments of ratios of quadratic forms in
normal random variables. \emph{Journal of Multivariate Analysis}, \strong{117},
229--245.
doi:\href{https://doi.org/10.1016/j.jmva.2013.03.002}{10.1016/j.jmva.2013.03.002}.

Smith, M. D. (1989). On the expectation of a ratio of quadratic forms
in normal variables. \emph{Journal of Multivariate Analysis}, \strong{31}, 244--257.
doi:\href{https://doi.org/10.1016/0047-259X(89)90065-1}{10.1016/0047-259X(89)90065-1}.

Watanabe, J. (2022). Exact expressions and numerical evaluation of average
evolvability measures for characterizing and comparing \strong{G} matrices.
\emph{bioRxiv} preprint, 2022.11.02.514929.
doi:\href{https://doi.org/10.1101/2022.11.02.514929}{10.1101/2022.11.02.514929}.
}
\seealso{
\code{\link{qfrm}} for simple ratio
}
