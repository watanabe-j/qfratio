% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R, R/qfratio-package.R
\name{Ap_int_cmE}
\alias{Ap_int_cmE}
\alias{Ap_int_nmE}
\alias{ABpq_int_cvE}
\alias{ABpq_int_cmE}
\alias{ABpq_int_nvE}
\alias{ABpq_int_nmE}
\alias{ABDpqr_int_cvE}
\alias{ABDpqr_int_cmE}
\alias{ABDpqr_int_nvE}
\alias{ABDpqr_int_nmE}
\alias{ApIq_int_cmE}
\alias{ApIq_int_nmE}
\alias{ApIq_npi_cvE}
\alias{ApIq_npi_nvE}
\alias{ApBq_int_cvE}
\alias{ApBq_int_cmE}
\alias{ApBq_int_nvE}
\alias{ApBq_int_nmE}
\alias{ApBq_npi_cvE}
\alias{ApBq_npi_cmE}
\alias{ApBq_npi_nvE}
\alias{ApBq_npi_nmE}
\alias{ApBIqr_int_cvE}
\alias{ApBIqr_int_cmE}
\alias{ApBIqr_int_nvE}
\alias{ApBIqr_int_nmE}
\alias{ApBIqr_npi_cvE}
\alias{ApBIqr_npi_cmE}
\alias{ApBIqr_npi_nvE}
\alias{ApBIqr_npi_nmE}
\alias{IpBDqr_gen_cvE}
\alias{IpBDqr_gen_cmE}
\alias{IpBDqr_gen_nvE}
\alias{IpBDqr_gen_nmE}
\alias{ApBDqr_int_cvE}
\alias{ApBDqr_int_cmE}
\alias{ApBDqr_int_nvE}
\alias{ApBDqr_int_nmE}
\alias{ApBDqr_npi_cvE}
\alias{ApBDqr_npi_cmE}
\alias{ApBDqr_npi_nvE}
\alias{ApBDqr_npi_nmE}
\alias{ApBDqr_int_cvEl}
\alias{ApBDqr_int_cmEl}
\alias{rqfpE}
\alias{qfrm_cpp}
\title{Internal C++ functions}
\usage{
Ap_int_cmE(A, p = 1)

Ap_int_nmE(A, mu, p = 1)

ABpq_int_cvE(LA, LB, p = 1, q = 1)

ABpq_int_cmE(A, LB, p = 1, q = 1)

ABpq_int_nvE(LA, LB, mu, p = 1, q = 1)

ABpq_int_nmE(A, LB, mu, p = 1, q = 1)

ABDpqr_int_cvE(LA, LB, LD, p = 1, q = 1, r = 1)

ABDpqr_int_cmE(A, LB, D, p = 1, q = 1, r = 1, nthreads = 1L)

ABDpqr_int_nvE(LA, LB, LD, mu, p = 1, q = 1, r = 1)

ABDpqr_int_nmE(A, LB, D, mu, p = 1, q = 1, r = 1)

ApIq_int_cmE(A, p = 1, q = 1)

ApIq_int_nmE(A, mu, p = 1, q = 1)

ApIq_npi_cvE(LA, b1, p = 1, q = 1, m = 100L, error_bound = TRUE)

ApIq_npi_nvE(LA, UA, b1, mu, p = 1, q = 1, m = 100L, error_bound = FALSE)

ApBq_int_cvE(LA, LB, b2, p = 1, q = 1, m = 100L, error_bound = TRUE)

ApBq_int_cmE(A, LA, UA, LB, b2, p = 1, q = 1, m = 100L, error_bound = TRUE)

ApBq_int_nvE(LA, LB, b2, mu, p = 1, q = 1, m = 100L, error_bound = TRUE)

ApBq_int_nmE(A, LA, UA, LB, b2, mu, p = 1, q = 1, m = 100L, error_bound = TRUE)

ApBq_npi_cvE(LA, LB, b1, b2, p = 1, q = 1, m = 100L, error_bound = FALSE)

ApBq_npi_cmE(A, LB, b1, b2, p = 1, q = 1, m = 100L, error_bound = FALSE)

ApBq_npi_nvE(LA, LB, b1, b2, mu, p = 1, q = 1, m = 100L, error_bound = FALSE)

ApBq_npi_nmE(A, LB, b1, b2, mu, p = 1, q = 1, m = 100L, error_bound = FALSE)

ApBIqr_int_cvE(LA, LB, b2, p = 1, q = 1, r = 1, m = 100L, error_bound = TRUE)

ApBIqr_int_cmE(
  A,
  LA,
  UA,
  LB,
  b2,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  error_bound = TRUE
)

ApBIqr_int_nvE(
  LA,
  LB,
  b2,
  mu,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  error_bound = TRUE
)

ApBIqr_int_nmE(
  A,
  LA,
  UA,
  LB,
  b2,
  mu,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  error_bound = TRUE,
  nthreads = 0L
)

ApBIqr_npi_cvE(LA, LB, b1, b2, p = 1, q = 1, r = 1, m = 100L)

ApBIqr_npi_cmE(A, LB, b1, b2, p = 1, q = 1, r = 1, m = 100L)

ApBIqr_npi_nvE(LA, LB, b1, b2, mu, p = 1, q = 1, r = 1, m = 100L)

ApBIqr_npi_nmE(A, LB, b1, b2, mu, p = 1, q = 1, r = 1, m = 100L, nthreads = 0L)

IpBDqr_gen_cvE(LB, LD, b2, b3, p = 1, q = 1, r = 1, m = 100L)

IpBDqr_gen_cmE(LB, D, b2, b3, p = 1, q = 1, r = 1, m = 100L)

IpBDqr_gen_nvE(LB, LD, b2, b3, mu, p = 1, q = 1, r = 1, m = 100L)

IpBDqr_gen_nmE(LB, D, b2, b3, mu, p = 1, q = 1, r = 1, m = 100L, nthreads = 0L)

ApBDqr_int_cvE(LA, LB, LD, b2, b3, p = 1, q = 1, r = 1, m = 100L)

ApBDqr_int_cmE(A, LB, D, b2, b3, p = 1, q = 1, r = 1, m = 100L, nthreads = 0L)

ApBDqr_int_nvE(LA, LB, LD, b2, b3, mu, p = 1, q = 1, r = 1, m = 100L)

ApBDqr_int_nmE(
  A,
  LB,
  D,
  b2,
  b3,
  mu,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  nthreads = 0L
)

ApBDqr_npi_cvE(LA, LB, LD, b1, b2, b3, p = 1, q = 1, r = 1, m = 100L)

ApBDqr_npi_cmE(
  A,
  LB,
  D,
  b1,
  b2,
  b3,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  nthreads = 0L
)

ApBDqr_npi_nvE(LA, LB, LD, b1, b2, b3, mu, p = 1, q = 1, r = 1, m = 100L)

ApBDqr_npi_nmE(
  A,
  LB,
  D,
  b1,
  b2,
  b3,
  mu,
  p = 1,
  q = 1,
  r = 1,
  m = 100L,
  nthreads = 0L
)

ApBDqr_int_cvEl(LA, LB, LD, b2, b3, p = 1L, q = 1L, r = 1L, m = 100L)

ApBDqr_int_cmEl(
  A,
  LB,
  D,
  b2,
  b3,
  p = 1L,
  q = 1L,
  r = 1L,
  m = 100L,
  nthreads = 0L
)

rqfpE(nit, A, B, D, p, q, r, mu, Sigma)
}
\arguments{
\item{A, B, D}{Argument matrices passed as \code{Eigen::MatrixXd}.
Symmetry is assumed.}

\item{p, q, r}{Exponents for \eqn{\mathbf{A}}, \eqn{\mathbf{B}}, and \eqn{\mathbf{D}}.
Passed as \code{double}.}

\item{mu}{Mean vector \eqn{\bm{\mu}} for \eqn{\mathbf{x}}
passed as \code{Eigen::ArrayXd}}

\item{LA, LB, LD}{Eigenvalues of the argument matrices passed as \code{Eigen::ArrayXd}}

\item{nthreads}{\code{int} to specify the number of threads in \code{OpenMP}-enabled
functions.  See "Details" in \code{\link{qfmrm}}.}

\item{b1, b2, b3}{Scaling coefficients for \eqn{\mathbf{A}}, \eqn{\mathbf{B}},
and \eqn{\mathbf{D}}.  Passed as \code{double}.}

\item{m}{\code{int} to specify the order of polynomials at which the series
expression is truncated}

\item{error_bound}{\code{bool} to specify whether the error bound is returned}

\item{UA}{Matrix whose columns are eigenvectors of \eqn{\mathbf{A}} corresponding to
\code{LA}.  Passed as \code{Eigen::MatrixXd}.}

\item{nit}{\code{int} to specify the number of iteration or sample size}

\item{Sigma}{Covariance matrix \eqn{\mathbf{\Sigma}} for \eqn{\mathbf{x}}.
Passed as \code{Eigen::MatrixXd}.}
}
\value{
All return a list via \code{Rcpp::List} of the following (as appropriate):
\itemize{
\item{\code{$ans}: }{Exact moment, from \code{double}}
\item{\code{$ansseq}: }{Series for the moment, from \code{Eigen::ArrayXd}}
\item{\code{$errseq}: }{Series of errors, from \code{Eigen::ArrayXd}}
\item{\code{$twosided}: }{Logical, from \code{bool}}
}
}
\description{
These are internal \code{C++} functions called from
corresponding \code{R} functions when \code{use_cpp = TRUE}.
Direct access by the user is \strong{not} assumed.
All parameters are assumed to be appropriately structured.
}
\details{
At present, \code{ApIq_int_nmE()} calls the \code{R} function
\code{gsl::hyperg_1F1()}, so will not be much faster than
the \code{R} equivalent.
Ideally, the \code{C++} library \code{gsl} (or the like) should be used with
\code{RcppGSL}, but this is not done (commented out in the source code)
to increase portability.

\code{rqfpE} uses \code{Rcpp::rnorm()},
which may not be particularly efficient.
}
\section{Functions}{
\itemize{
\item \code{Ap_int_cmE()}: \code{qfm_Ap_int()}, central

\item \code{Ap_int_nmE()}: \code{qfm_Ap_int()}, noncentral

\item \code{ABpq_int_cvE()}: \code{qfpm_ABpq_int()}, central & vector

\item \code{ABpq_int_cmE()}: \code{qfpm_ABpq_int()}, central & matrix

\item \code{ABpq_int_nvE()}: \code{qfpm_ABpq_int()}, noncentral & vector

\item \code{ABpq_int_nmE()}: \code{qfpm_ABpq_int()}, noncentral & matrix

\item \code{ABDpqr_int_cvE()}: \code{qfpm_ABDpqr_int()}, central & vector

\item \code{ABDpqr_int_cmE()}: \code{qfpm_ABDpqr_int()}, central & matrix

\item \code{ABDpqr_int_nvE()}: \code{qfpm_ABDpqr_int()}, noncentral & vector

\item \code{ABDpqr_int_nmE()}: \code{qfpm_ABDpqr_int()}, central & matrix

\item \code{ApIq_int_cmE()}: \code{qfrm_ApIq_int()}, central

\item \code{ApIq_int_nmE()}: \code{qfrm_ApIq_int()}, noncentral

\item \code{ApIq_npi_cvE()}: \code{qfrm_ApIq_npi()}, central

\item \code{ApIq_npi_nvE()}: \code{qfrm_ApIq_npi()}, noncentral

\item \code{ApBq_int_cvE()}: \code{qfrm_ApBq_int()}, central & vector

\item \code{ApBq_int_cmE()}: \code{qfrm_ApBq_int()}, central & matrix

\item \code{ApBq_int_nvE()}: \code{qfrm_ApBq_int()}, noncentral & vector

\item \code{ApBq_int_nmE()}: \code{qfrm_ApBq_int()}, noncentral & matrix

\item \code{ApBq_npi_cvE()}: \code{qfrm_ApBq_npi()}, central & vector

\item \code{ApBq_npi_cmE()}: \code{qfrm_ApBq_npi()}, central & matrix

\item \code{ApBq_npi_nvE()}: \code{qfrm_ApBq_npi()}, noncentral & vector

\item \code{ApBq_npi_nmE()}: \code{qfrm_ApBq_npi()}, noncentral & matrix

\item \code{ApBIqr_int_cvE()}: \code{qfmrm_ApBIqr_int()}, central & vector

\item \code{ApBIqr_int_cmE()}: \code{qfmrm_ApBIqr_int()}, central & matrix

\item \code{ApBIqr_int_nvE()}: \code{qfmrm_ApBIqr_int()}, noncentral & vector

\item \code{ApBIqr_int_nmE()}: \code{qfmrm_ApBIqr_int()}, noncentral & matrix

\item \code{ApBIqr_npi_cvE()}: \code{qfmrm_ApBIqr_npi()}, central & vector

\item \code{ApBIqr_npi_cmE()}: \code{qfmrm_ApBIqr_npi()}, central & matrix

\item \code{ApBIqr_npi_nvE()}: \code{qfmrm_ApBIqr_npi()}, noncentral & vector

\item \code{ApBIqr_npi_nmE()}: \code{qfmrm_ApBIqr_npi()}, noncentral & matrix

\item \code{IpBDqr_gen_cvE()}: \code{qfmrm_IpBDqr_gen()}, central & vector

\item \code{IpBDqr_gen_cmE()}: \code{qfmrm_IpBDqr_gen()}, central & matrix

\item \code{IpBDqr_gen_nvE()}: \code{qfmrm_IpBDqr_gen()}, noncentral & vector

\item \code{IpBDqr_gen_nmE()}: \code{qfmrm_IpBDqr_gen()}, noncentral & matrix

\item \code{ApBDqr_int_cvE()}: \code{qfmrm_ApBDqr_int()}, central & vector

\item \code{ApBDqr_int_cmE()}: \code{qfmrm_ApBDqr_int()}, central & matrix

\item \code{ApBDqr_int_nvE()}: \code{qfmrm_ApBDqr_int()}, noncentral & vector

\item \code{ApBDqr_int_nmE()}: \code{qfmrm_ApBDqr_int()}, noncentral & matrix

\item \code{ApBDqr_npi_cvE()}: \code{qfmrm_ApBDqr_npi()}, central & vector

\item \code{ApBDqr_npi_cmE()}: \code{qfmrm_ApBDqr_npi()}, central & matrix

\item \code{ApBDqr_npi_nvE()}: \code{qfmrm_ApBDqr_npi()}, noncentral & vector

\item \code{ApBDqr_npi_nmE()}: \code{qfmrm_ApBDqr_npi()}, noncentral & matrix

\item \code{ApBDqr_int_cvEl()}: \code{qfmrm_ApBDqr_int()}, central & vector, long double

\item \code{ApBDqr_int_cmEl()}: \code{qfmrm_ApBDqr_int()}, central & matrix, long double

\item \code{rqfpE()}: \code{rqfp()}

}}
