% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dk_funs.R
\name{d1_i}
\alias{d1_i}
\alias{dtil1_i}
\alias{dtil1_i_v}
\alias{dtil1_i_m}
\title{Coefficients in polynomial expansion of generating function---single matrix}
\usage{
d1_i(L, m = 100L)

dtil1_i_v(L, mu = rep.int(0, n), m = 100L)

dtil1_i_m(A, mu = rep.int(0, n), m = 100L)
}
\arguments{
\item{L}{Vector of eigenvalues of the argument matrix}

\item{m}{Integer-alike to specify the order of polynomials}

\item{mu}{Mean vector \eqn{\bm{\mu}} for \eqn{\mathbf{x}}}

\item{A}{Argument matrix.  Assumed to be symmetric in these functions.}
}
\value{
Vector of length \code{m + 1}, corresponding to
the 0th, 1st, ..., and mth order terms.
Hence, the \code{[m + 1]}-th element should be extracted
when the coefficient for the mth order term is required.

Has the attribute \code{"logscale"} as described in "Scaling" above.
}
\description{
These are internal functions to calculate the coefficients
in polynomial expansion of generating functions for quadratic forms
in multivariate normal variables.

\code{d1_i()} is for standard multivariate normal variables,
\eqn{\mathbf{x} \sim N(\mathbf{0}, \mathbf{I}_n)}.

\code{dtil1_i_v()} is for noncentral multivariate normal variables,
\eqn{\mathbf{x} \sim N(\bm{\mu}, \mathbf{I}_n)}.

\code{dtil1_i_m()} is a wrapper for \code{dtil1_i_v()}
and takes the argument matrix rather than its eigenvalues.
}
\details{
\code{d1_i()} calculates \eqn{d_k(\mathbf{A})}, and \code{dtil1_i_v()} and
\code{dtil1_i_m()} calculate \eqn{\tilde{d}_k(\mathbf{A})} in
Hillier et al. (2009, 2014) and Bao & Kan (2013).
The former is related to the top-order zonal polynomial
\eqn{C_{[k]}(\mathbf{A})} in the following way:
\eqn{ d_k(\mathbf{A}) = \frac{1}{k!} \left( \frac{1}{2} \right)_k C_{[k]}(\mathbf{A}) },
where \eqn{(x)_k = x (x + 1) \dots (x + k - 1)}.

These functions calculate the coefficients based on the super-short
recursion algorithm described in Hillier et al. (2014: 3.2, eqs. 28--30).
\subsection{Scaling:}{

The coefficients described herein (and in \code{\link{d2_ij}} and
\code{\link{d3_ijk}}) can become very large for higher-order terms,
so there is a practical risk of numerical overflow when applied to
large (\eqn{n > 100}, say) matrices.
To avoid numerical overflow, these functions automatically scale
coefficients (and temporary objects used to calculate them) by a large number
(\code{1e10} at present) when any value in the temporary objects
exceeds a predefined threshold (\code{.Machine$double.xmax / 100 / n}).
This scaling happens order-wise; i.e., it influences all the coefficients
of the same order in multidimensional coefficients (in \code{\link{d2_ij}}
and \code{\link{d3_ijk}}) and the coefficients of the subsequent orders.

These scaling factors are recorded in the attribute \code{"logscale"} of the
return value, which is a vector/matrix/array whose size is identical to the
return value, so that \code{value / exp(attr(value, "logscale"))} equals
the original quantities to be obtained (if there were no overflow).

The \code{qfrm} and \code{qfmrm} functions handle return values of these
functions by first multiplying them with hypergeometric coefficients
(which are typically \eqn{\ll 1}) and then scaling the products back
to the original scale using the recorded scaling factors.
(To be precise, this typically happens within \code{\link{hgs}} functions.)
The \code{C++} functions handle the problem similarly (but by using
separate objects rather than attributes).

However, this procedure does not always mitigate the problem in
multidimensional coefficients; when there are very large and very small
coefficients in the same order, smaller ones can diminish to the numerical
\code{0} after repeated scaling.
(The problem can be difficult to detect, but is typically diagnosed by a sudden
plateau rather than a gradual saturation of the profile of series expression.)
As this seems technically difficult to avoid without implementing
cumbersome and inefficient coefficient-wise scaling, the only workaround
implemented in this package is to use the \code{long double} variable type
in \code{C++} versions (see \code{\link{qfrm}} and \code{\link{qfmrm}}).
}
}
\references{
Bao, Y. & Kan, R. (2013). On the moments of ratios of quadratic forms in
normal random variables. \emph{Journal of Multivariate Analysis}, \strong{117},
229--245.
doi:\href{https://doi.org/10.1016/j.jmva.2013.03.002}{10.1016/j.jmva.2013.03.002}.

Hillier, G., Kan, R, & Wang, X. (2009). Computationally efficient recursions
for top-order invariant polynomials with applications.
\emph{Econometric Theory}, \strong{25}, 211--242.
doi:\href{https://doi.org/10.1017/S0266466608090075}{10.1017/S0266466608090075}.

Hillier, G., Kan, R, & Wang, X. (2014). Generating functions and
short recursions, with applications to the moments of quadratic forms
in noncentral normal vectors. \emph{Econometric Theory}, \strong{30}, 436--473.
doi:\href{https://doi.org/10.1017/S0266466613000364}{10.1017/S0266466613000364}.
}
\seealso{
\code{\link{qfpm}}, \code{\link{qfrm}}, and \code{\link{qfmrm}} are
major front-end functions that utilize these functions

\code{\link{dtil2_pq}} for \eqn{\tilde{d}}
used for moments of a product of quadratic forms

\code{\link{d2_ij}} and \code{\link{d3_ijk}} for \eqn{d}, \eqn{h},
\eqn{\tilde{h}}, and \eqn{\hat{h}} used for moments of ratios
of quadratic forms
}
